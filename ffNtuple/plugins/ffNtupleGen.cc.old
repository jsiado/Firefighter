#include "Firefighter/ffNtuple/interface/ffNtupleBase.h"

#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/GeometrySurface/interface/Plane.h"
#include "DataFormats/GeometrySurface/interface/Cylinder.h"
#include "SimDataFormats/GeneratorProducts/interface/HepMCProduct.h"
#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"

#include "MagneticField/Engine/interface/MagneticField.h"
#include "MagneticField/Records/interface/IdealMagneticFieldRecord.h"
#include "TrackPropagation/RungeKutta/interface/defaultRKPropagator.h"
#include "TrackPropagation/RungeKutta/interface/RKPropagatorInS.h"
#include "FastSimulation/Event/interface/FSimEvent.h"
#include "FastSimulation/Particle/interface/ParticleTable.h"
#include "FastSimulation/CaloGeometryTools/interface/Transform3DPJ.h"
#include "SimGeneral/HepPDTRecord/interface/PDTRecord.h"
#include "PhysicsTools/HepMCCandAlgos/interface/MCTruthHelper.h"

#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/ESWatcher.h"

#include <memory>

namespace ff {

  class Coordinates
  {
    public:
      Coordinates() : x(0.), y(0.), z(0.), eta(0.), phi(0.) {}
      float x, y, z, eta, phi;
      inline math::XYZTLorentzVectorD toVector()
      {
        return math::XYZTLorentzVectorD(x, y, z, 0);
      }
  };

  class SimpleTrackPropagator
  {
    public:
      SimpleTrackPropagator(const MagneticField* f) :
        field_(f),
        prod_(field_, alongMomentum),
        absz_target_(0),
        r_target_(0)
      {
        ROOT::Math::SMatrixIdentity id;
        AlgebraicSymMatrix55 C(id);
        const float uncert = 0.001;
        C *= uncert;
        err_ = CurvilinearTrajectoryError(C);
      }

      void setPropagationTargetZ(const float& z);
      void setPropagationTargetR(const float& r);
      void setPropagationTargetRZ(const float& r, const float& z);
      
      bool propagate(const double px, const double py, const double pz,
                     const double x,  const double y,  const double z,
                     const float charge, Coordinates& output) const;
      
      bool propagate(const math::XYZTLorentzVectorD& momentum,
                     const math::XYZTLorentzVectorD& position,
                     const float charge, Coordinates& output) const;
    
    private:
      SimpleTrackPropagator() :
        field_(nullptr),
        prod_(field_, alongMomentum),
        absz_target_(0),
        r_target_(0)
      {}

      const RKPropagatorInS&
      RKProp() const
      {
        return prod_.propagator;
      }

      Plane::PlanePointer targetPlaneForward_;
      Plane::PlanePointer targetPlaneBackward_;
      Cylinder::CylinderPointer targetCylinder_;

      const MagneticField* field_;
      CurvilinearTrajectoryError err_;
      defaultRKPropagator::Product prod_;
      float absz_target_;
      float r_target_;
  };

  void
  SimpleTrackPropagator::setPropagationTargetZ(const float& z)
  {
    targetPlaneForward_ = Plane::build(Plane::PositionType(0, 0, std::abs(z)),
                                       Plane::RotationType());
    targetPlaneBackward_= Plane::build(Plane::PositionType(0, 0, -std::abs(z)),
                                       Plane::RotationType());
    absz_target_ = std::abs(z);
  }

  void
  SimpleTrackPropagator::setPropagationTargetR(const float& r)
  {
    targetCylinder_ = Cylinder::build(r,
                                      Cylinder::PositionType(),
                                      Cylinder::RotationType());
    r_target_ = r;
  }

  void
  SimpleTrackPropagator::setPropagationTargetRZ(const float& r,
                                                const float& z)
  {
    setPropagationTargetR(r);
    setPropagationTargetZ(z);
  }

  bool
  SimpleTrackPropagator::propagate(const double px, const double py, const double pz,
                                   const double x,  const double y,  const double z,
                                   const float charge, Coordinates& output) const
  {
    output = Coordinates();

    using TSOS = TrajectoryStateOnSurface;
    
    GlobalPoint         startingPosition(x, y, z);
    GlobalVector        startingMomentum(px, py, pz);
    Plane::ConstPlanePointer startingPlane = Plane::build(Plane::PositionType(x, y, z),
                                                     Plane::RotationType());
    Cylinder::ConstCylinderPointer startingCylinder = Cylinder::build(std::hypot(x, y),
                                                                      Cylinder::PositionType(x, y, z),
                                                                      Cylinder::RotationType());
    TSOS startingStateP(GlobalTrajectoryParameters(startingPosition, startingMomentum, charge, field_),
                        err_,
                        *startingPlane);
    TSOS startingStateC(GlobalTrajectoryParameters(startingPosition, startingMomentum, charge, field_),
                        err_,
                        *startingCylinder);
    
    TSOS trackState;
    trackState = RKProp().propagate(startingStateC, *targetCylinder_);
    if (trackState.isValid())
    {
      if (trackState.globalPosition().z() < targetPlaneBackward_->position().z())
      {
        trackState = RKProp().propagate(startingStateP, *targetPlaneBackward_);
        if (!trackState.isValid()
            or trackState.globalPosition().perp() > targetCylinder_->radius())
        { return false;}
      } else if (trackState.globalPosition().z() > targetPlaneForward_->position().z())
      {
        trackState = RKProp().propagate(startingStateP, *targetPlaneForward_);
        if (!trackState.isValid()
            or trackState.globalPosition().perp() > targetCylinder_->radius())
        { return false;}
      }
    } else
    {
      return false;
    }


    output.x   = trackState.globalPosition().x();
    output.y   = trackState.globalPosition().y();
    output.z   = trackState.globalPosition().z();
    output.eta = trackState.globalPosition().eta();
    output.phi = trackState.globalPosition().phi();

    return true;

  }

  bool
  SimpleTrackPropagator::propagate(const math::XYZTLorentzVectorD& momentum,
                                   const math::XYZTLorentzVectorD& position,
                                   const float charge, Coordinates& output) const
  {
    return propagate(momentum.px(), momentum.py(), momentum.pz(),
                     position.x(), position.y(), position.z(),
                     charge, output);
  }

} // namespace ff


class ffNtupleGen : public ffNtupleBase
{
  public:
    ffNtupleGen(const edm::ParameterSet&);

    void initialize(TTree&, const edm::ParameterSet&, edm::ConsumesCollector&&) final;
    void fill(const edm::Event&, const edm::EventSetup&) final;

    using Point = ROOT::Math::Transform3DPJ::Point;
  
  private:
    void clear() final;

    MCTruthHelper<HepMC::GenParticle> mcTruthHelper_;
    
    edm::EDGetToken gen_token_;
    edm::EDGetToken gen_PU_token_;

    std::vector<std::pair<float, float>> cylinderBounds_;

    int gen_n_;
    int gen_PUNumInt_;
    float gen_TrueNumInt_;

    float vtx_x_;
    float vtx_y_;
    float vtx_z_;

    std::vector<float> genpart_eta_;
    std::vector<float> genpart_phi_;
    std::vector<float> genpart_pt_;
    std::vector<float> genpart_energy_;
    std::vector<float> genpart_ovx_;
    std::vector<float> genpart_ovy_;
    std::vector<float> genpart_ovz_;
    std::vector<int> genpart_mother_;
    std::vector<int> genpart_pid_;
    std::vector<int> genpart_gen_;
    std::vector<std::vector<float>> genpart_posx_;
    std::vector<std::vector<float>> genpart_posy_;
    std::vector<std::vector<float>> genpart_posz_;
    std::vector<std::vector<float>> genpart_poseta_;
    std::vector<std::vector<float>> genpart_posphi_;

    std::vector<float> gen_eta_;
    std::vector<float> gen_phi_;
    std::vector<float> gen_pt_;
    std::vector<float> gen_energy_;
    std::vector<int>   gen_charge_;
    std::vector<int>   gen_pdgid_;
    std::vector<int>   gen_status_;
    std::vector<std::vector<int>> gen_daughters_;

    // tool for simulated tracks
    std::unique_ptr<FSimEvent> mySimEvent_;
    const MagneticField* aField_;

    edm::EDGetToken simTracks_token_;
    edm::EDGetToken simVertices_token_;
    edm::EDGetToken hepmcev_token_;

    edm::ESWatcher<PDTRecord> pdt_watcher_;
    edm::ESWatcher<IdealMagneticFieldRecord> magfield_watcher_;
};

DEFINE_EDM_PLUGIN(ffNtupleFactory,
                  ffNtupleGen,
                  "ffNtupleGen");


ffNtupleGen::ffNtupleGen(const edm::ParameterSet& ps) :
  ffNtupleBase(ps)
{}

void
ffNtupleGen::initialize(TTree& tree,
                       const edm::ParameterSet& ps,
                       edm::ConsumesCollector&& cc)
{
  edm::ParameterSet particleFilter_(ps.getParameter<edm::ParameterSet>("particleFilter"));
  mySimEvent_ = std::make_unique<FSimEvent>(particleFilter_);

  gen_token_ = cc.consumes<reco::GenParticleCollection>(ps.getParameter<edm::InputTag>("GenParticles"));
  gen_PU_token_ = cc.consumes<std::vector<PileupSummaryInfo>>(ps.getParameter<edm::InputTag>("GenPU"));

  tree.Branch("gen_n", &gen_n_, "gen_n/I");
  tree.Branch("gen_PUNumInt", &gen_PUNumInt_ ,"gen_PUNumInt/I");
  tree.Branch("gen_TrueNumInt", &gen_TrueNumInt_ ,"gen_TrueNumInt/F");

  hepmcev_token_ = cc.consumes<edm::HepMCProduct>(ps.getParameter<edm::InputTag>("MCEvent"));
  simTracks_token_ = cc.consumes<std::vector<SimTrack>>(ps.getParameter<edm::InputTag>("SimTracks"));
  simVertices_token_ = cc.consumes<std::vector<SimVertex>>(ps.getParameter<edm::InputTag>("SimVertices"));

  const std::vector<edm::ParameterSet>& cylinder_rz_ = ps.getParameterSetVector("CylinderRZ");
  for (const auto& rz : cylinder_rz_)
  {
    const double& r_ = rz.getParameter<double>("radius");
    const double& z_ = rz.getParameter<double>("absZ");
    cylinderBounds_.emplace_back(r_, z_);
  }

  tree.Branch("vtx_x", &vtx_x_);
  tree.Branch("vtx_y", &vtx_y_);
  tree.Branch("vtx_z", &vtx_z_);

  tree.Branch("gen_eta", &gen_eta_);
  tree.Branch("gen_phi", &gen_phi_);
  tree.Branch("gen_pt", &gen_pt_);
  tree.Branch("gen_energy", &gen_energy_);
  tree.Branch("gen_charge", &gen_charge_);
  tree.Branch("gen_pdgid", &gen_pdgid_);
  tree.Branch("gen_status", &gen_status_);
  tree.Branch("gen_daughters", &gen_daughters_);

  tree.Branch("genpart_eta", &genpart_eta_);
  tree.Branch("genpart_phi", &genpart_phi_);
  tree.Branch("genpart_pt", &genpart_pt_);
  tree.Branch("genpart_energy", &genpart_energy_);
  tree.Branch("genpart_mother", &genpart_mother_);
  tree.Branch("genpart_pid", &genpart_pid_);
  tree.Branch("genpart_gen", &genpart_gen_);
  tree.Branch("genpart_ovx", &genpart_ovx_);
  tree.Branch("genpart_ovy", &genpart_ovy_);
  tree.Branch("genpart_ovz", &genpart_ovz_);
  tree.Branch("genpart_posx", &genpart_posx_);
  tree.Branch("genpart_posy", &genpart_posy_);
  tree.Branch("genpart_posz", &genpart_posz_);
  tree.Branch("genpart_poseta", &genpart_poseta_);
  tree.Branch("genpart_posphi", &genpart_posphi_);
}

void
ffNtupleGen::fill(const edm::Event& e,
                  const edm::EventSetup& es)
{
  clear();

  using namespace edm;
  using namespace std;
  Handle<vector<PileupSummaryInfo>> PupInfo_h;
  e.getByToken(gen_PU_token_, PupInfo_h);
  const vector<PileupSummaryInfo>& PupInfo = *PupInfo_h;

  if (pdt_watcher_.check(es))
  {
    ESHandle<HepPDT::ParticleDataTable> pdt;
    es.get<PDTRecord>().get(pdt);
    mySimEvent_->initializePdt(&(*pdt));
  }

  if (magfield_watcher_.check(es))
  {
    ESHandle<MagneticField> magfield;
    es.get<IdealMagneticFieldRecord>().get(magfield);
    aField_ = &(*magfield);
  }

  ParticleTable::Sentry ptable(mySimEvent_->theTable());
  Handle<HepMCProduct> hepmcev_h;
  Handle<vector<SimTrack>> simTracks_h;
  Handle<vector<SimVertex>> simVertices_h;

  e.getByToken(hepmcev_token_, hepmcev_h);
  e.getByToken(simTracks_token_, simTracks_h);
  e.getByToken(simVertices_token_, simVertices_h);
  mySimEvent_->fill(*simTracks_h, *simVertices_h);
  auto _eid = e.id();
  mySimEvent_->fill(*(hepmcev_h)->GetEvent(), _eid);

  HepMC::GenVertex* primaryVertex = *(hepmcev_h)->GetEvent()->vertices_begin();
  const float mm2cm = 0.1;
  vtx_x_ = primaryVertex->position().x() * mm2cm; // length unit is mm in HepMC, cm in CMSSW
  vtx_y_ = primaryVertex->position().y() * mm2cm;
  vtx_z_ = primaryVertex->position().z() * mm2cm;
  Point sim_pv(vtx_x_, vtx_y_, vtx_z_);

  // debug
  cout<<endl<<">>Event "<<_eid.event()<<endl;
  
  // Loop through SimTrack, build vtxId->count map
  map<int, int> vtxIdCount;
  for (vector<SimTrack>::const_iterator isim = simTracks_h->begin();
       isim != simTracks_h->end(); ++isim)
  {
    if (abs(isim->type()) != 13
        and abs(isim->type()) != 11) continue;
    if (isim->noGenpart()) continue;
    int vidx = isim->vertIndex();
    vtxIdCount[vidx]++;
  }

  // keep only vetex Id that has more than 1 daughter
  vector<int> vtxIdWithMulDau;
  for (const auto& idcnt : vtxIdCount)
  {
    int id = idcnt.first;
    int cnt= idcnt.second;
    if (cnt>1) vtxIdWithMulDau.push_back(id);
  }

  // filter SimTrack + propagate
  for (vector<SimTrack>::const_iterator isim = simTracks_h->begin();
       isim != simTracks_h->end(); ++isim)
  {
    if (abs((*isim).type()) != 13
        and abs(isim->type()) != 11) continue;
    if (isim->noGenpart()) continue;
    
    int gidx = isim->genpartIndex();
    int vidx = isim->vertIndex();
    if (
      find(
        vtxIdWithMulDau.begin(), vtxIdWithMulDau.end(), vidx
        ) == vtxIdWithMulDau.end()
      ) continue;
    const auto& vtx = (*simVertices_h)[vidx];
    // int gstatus = hepmcev_h->GetEvent()->barcode_to_particle(gidx)->status();
    int pid = isim->type();
    float pt = isim->momentum().Pt();
    float eta= isim->momentum().eta();
    float phi= isim->momentum().phi();
    float vtx_r = vtx.position().Rho();
    float vtx_z = vtx.position().Z();
    if (pt<2.) continue;

    // debug
    // cout<<"\t"<<gidx<<"  "<<vidx<<"  "<<pid<<"  "<<pt<<"  "<<eta<<"  "<<phi
    //           <<"  "<<vtx_r<<"  "<<vtx_z<<endl;

    vector<float> xp, yp, zp, etap, phip;
    ff::SimpleTrackPropagator indivPropagator(aField_);
    for (const auto& cbound : cylinderBounds_)
    {
      const float& cb_r = cbound.first;
      const float& cb_z = cbound.second;

      float _x(NAN), _y(NAN), _z(NAN), _eta(NAN), _phi(NAN);

      if (    abs(vtx.position().z())   <= cb_z
          and abs(vtx.position().Rho()) <= cb_r)
      {
        indivPropagator.setPropagationTargetRZ(cb_r, cb_z);
        ff::Coordinates propcoords;
        
        bool propsucess;
        propsucess = indivPropagator.propagate(isim->momentum(),
                                               vtx.position(),
                                               isim->charge(),
                                               propcoords);
        if (propsucess)
        {
          _x   = propcoords.x;
          _y   = propcoords.y;
          _z   = propcoords.z;
          _eta = propcoords.eta;
          _phi = propcoords.phi;
        }
      }

      xp  .push_back(_x);
      yp  .push_back(_y);
      zp  .push_back(_z);
      etap.push_back(_eta);
      phip.push_back(_phi);
    }

    //debug
    // cout<<"\t\t|";
    // for (size_t i(0); i!=cylinderBounds_.size(); ++i)
    // {
    //   cout<<"("<<etap[i]<<", "<<phip[i]<<") | ";
    // }
    // cout<<endl;
  }



  vector<FSimTrack*> allselectedgentracks;
  unsigned int npart = mySimEvent_->nTracks();
  for (unsigned int i(0); i<npart; ++i)
  {

    vector<float> xp, yp, zp, etap, phip;
    FSimTrack& myTrack(mySimEvent_->track(i));

    /*int simpid = myTrack.type();
    if (abs(simpid) == 13)
    {
      float pt = myTrack.momentum().Pt();
      float eta= myTrack.momentum().eta();
      float phi= myTrack.momentum().phi();
      cout<<"\t"<<simpid<<"  "<<pt<<"  "<<eta<<"  "<<phi<<endl;
    }*/
    
    if (myTrack.noGenpart()
        or myTrack.genParticle()==nullptr)
    {
      continue;
    }
    
    const auto& _hepMcPar = *myTrack.genParticle();


    // if (!mcTruthHelper_.isHardProcess(_hepMcPar)
    //     or abs(_hepMcPar.pdg_id()) < 9)
    // {
    //   continue;
    // }
    if (abs(_hepMcPar.pdg_id()) != 11
        and abs(_hepMcPar.pdg_id()) != 13)
    {
      continue;
    }

    // debug
    // cout<<"\t"<<_hepMcPar.pdg_id()
    //     <<"  "<<_hepMcPar.status()
    //     <<"  "<<_hepMcPar.momentum().eta()
    //     <<"  "<<_hepMcPar.momentum().phi()
    //     <<"  "<<_hepMcPar.momentum().perp()
    //     <<endl;
    
    ff::SimpleTrackPropagator indivPropagator(aField_);
    for (const auto& cbound : cylinderBounds_)
    {
      const float& cb_r = cbound.first;
      const float& cb_z = cbound.second;

      if (abs(myTrack.vertex().position().z()) > cb_z
          or abs(myTrack.vertex().position().Rho()) > cb_r)
      {
        xp  .push_back(NAN);
        yp  .push_back(NAN);
        zp  .push_back(NAN);
        etap.push_back(NAN);
        phip.push_back(NAN);
        continue;
      }

      indivPropagator.setPropagationTargetRZ(cb_r, cb_z);
      ff::Coordinates propcoords;
      indivPropagator.propagate(myTrack.momentum(),
                                myTrack.vertex().position(),
                                myTrack.charge(),
                                propcoords);
      
      xp  .push_back(propcoords.x);
      yp  .push_back(propcoords.y);
      zp  .push_back(propcoords.z);
      etap.push_back(propcoords.eta);
      phip.push_back(propcoords.phi);
    }

    auto orig_vtx = myTrack.vertex().position();

    allselectedgentracks.push_back(&myTrack);
    genpart_eta_.push_back(myTrack.momentum().eta());
    genpart_phi_.push_back(myTrack.momentum().phi());
    genpart_pt_ .push_back(myTrack.momentum().pt());
    genpart_energy_.push_back(myTrack.momentum().energy());

    genpart_ovx_.push_back(orig_vtx.x());
    genpart_ovy_.push_back(orig_vtx.y());
    genpart_ovz_.push_back(orig_vtx.z());

    genpart_pid_.push_back(myTrack.type());
    genpart_gen_.push_back(myTrack.genpartIndex());

    genpart_posx_.push_back(xp);
    genpart_posy_.push_back(yp);
    genpart_posz_.push_back(zp);
    genpart_poseta_.push_back(etap);
    genpart_posphi_.push_back(phip);
  }

  Handle<vector<reco::GenParticle>> gen_h;
  e.getByToken(gen_token_, gen_h);
  gen_n_ = gen_h->size();

  for (const auto& particle : *gen_h)
  {
    if (!particle.isHardProcess()
        or abs(particle.pdgId())<9)
    {
      continue;
    }

    // debug
    cout<<"\t"<<particle.pdgId()<<"  "<<particle.eta()<<"  "<<particle.phi()<<"  "
              <<particle.pt()<<"  "<<particle.vertex().Rho()<<"  "<<particle.vertex().Z()<<endl;
    const auto& vtx = particle.vertex();

    gen_eta_.push_back(particle.eta());
    gen_phi_.push_back(particle.phi());
    gen_pt_.push_back(particle.pt());
    gen_energy_.push_back(particle.energy());
    gen_charge_.push_back(particle.charge());
    gen_pdgid_.push_back(particle.pdgId());
    gen_status_.push_back(particle.status());
    vector<int> daughters(particle.daughterRefVector().size(), 0);
    for (unsigned j = 0; j < particle.daughterRefVector().size(); ++j) {
      daughters[j] = static_cast<int>(particle.daughterRefVector().at(j).key());
    }
    gen_daughters_.push_back(daughters);

    if (particle.charge()==0) continue;
    vector<float> xp, yp, zp, etap, phip;
    ff::SimpleTrackPropagator indivPropagator(aField_);
    for (const auto& cbound : cylinderBounds_)
    {
      const float& cb_r = cbound.first;
      const float& cb_z = cbound.second;

      float _x(NAN), _y(NAN), _z(NAN), _eta(NAN), _phi(NAN);

      if (    abs(vtx.z())   <= cb_z
          and abs(vtx.Rho()) <= cb_r)
      {
        indivPropagator.setPropagationTargetRZ(cb_r, cb_z);
        ff::Coordinates propcoords;
        
        bool propsucess;
        propsucess = indivPropagator.propagate(particle.px(), particle.py(), particle.pz(),
                                               vtx.x(), vtx.y(), vtx.z(),
                                               particle.charge(),
                                               propcoords);
        if (propsucess)
        {
          _x   = propcoords.x;
          _y   = propcoords.y;
          _z   = propcoords.z;
          _eta = propcoords.eta;
          _phi = propcoords.phi;
        }
      }

      xp  .push_back(_x);
      yp  .push_back(_y);
      zp  .push_back(_z);
      etap.push_back(_eta);
      phip.push_back(_phi);
    }

    //debug
    cout<<"\t\t|";
    for (size_t i(0); i!=cylinderBounds_.size(); ++i)
    {
      cout<<"("<<etap[i]<<", "<<phip[i]<<") | ";
    }
    cout<<endl;


  }

  // associate gen particles to mothers
  genpart_mother_.resize(genpart_posz_.size(), -1);
  for (size_t i = 0; i < allselectedgentracks.size(); i++)
  {
    const auto tracki = allselectedgentracks.at(i);

    for (size_t j = i + 1; j < allselectedgentracks.size(); j++)
    {
      const auto trackj = allselectedgentracks.at(j);

      if (!tracki->noMother())
      {
        if (&tracki->mother() == trackj) genpart_mother_.at(i) = j;
      }
      if (!trackj->noMother())
      {
        if (&trackj->mother() == tracki) genpart_mother_.at(j) = i;
      }
    }
  }


  for(const auto& PVI : PupInfo)
  {
    if(PVI.getBunchCrossing() == 0)
    { 
      gen_PUNumInt_ = PVI.getPU_NumInteractions();
      gen_TrueNumInt_ = PVI.getTrueNumInteractions();
    }
  }
}

void
ffNtupleGen::clear()
{
  gen_n_ = 0;
  gen_PUNumInt_ = 0;
  gen_TrueNumInt_ = 0.;

  vtx_x_ = 0;
  vtx_y_ = 0;
  vtx_z_ = 0;

  genpart_eta_.clear();
  genpart_phi_.clear();
  genpart_pt_.clear();
  genpart_energy_.clear();
  genpart_ovx_.clear();
  genpart_ovy_.clear();
  genpart_ovz_.clear();
  genpart_mother_.clear();
  genpart_pid_.clear();
  genpart_gen_.clear();
  genpart_posx_.clear();
  genpart_posy_.clear();
  genpart_posz_.clear();
  genpart_poseta_.clear();
  genpart_posphi_.clear();

  gen_eta_.clear();
  gen_phi_.clear();
  gen_pt_.clear();
  gen_energy_.clear();
  gen_charge_.clear();
  gen_pdgid_.clear();
  gen_status_.clear();
  gen_daughters_.clear();
}