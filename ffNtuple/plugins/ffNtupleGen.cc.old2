#include "Firefighter/ffNtuple/interface/ffNtupleBase.h"

#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/GeometrySurface/interface/Plane.h"
#include "DataFormats/GeometrySurface/interface/Cylinder.h"
#include "DataFormats/Math/interface/deltaR.h"
#include "DataFormats/Math/interface/LorentzVectorFwd.h"
#include "DataFormats/Math/interface/Point3D.h"
#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"

#include "MagneticField/Engine/interface/MagneticField.h"
#include "MagneticField/Records/interface/IdealMagneticFieldRecord.h"
#include "TrackPropagation/RungeKutta/interface/defaultRKPropagator.h"
#include "TrackPropagation/RungeKutta/interface/RKPropagatorInS.h"

#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/ESWatcher.h"

#include <memory>


namespace ff {

  class Coordinates
  {
    public:
      Coordinates() : x(0.), y(0.), z(0.), eta(0.), phi(0.) {}
      float x, y, z, eta, phi;
      inline math::XYZTLorentzVectorD toVector()
      {
        return math::XYZTLorentzVectorD(x, y, z, 0);
      }
  };

  class SimpleTrackPropagator
  {
    public:
      SimpleTrackPropagator(const MagneticField* f) :
        field_(f),
        prod_(field_, alongMomentum),
        absz_target_(0),
        r_target_(0)
      {
        ROOT::Math::SMatrixIdentity id;
        AlgebraicSymMatrix55 C(id);
        const float uncert = 0.001;
        C *= uncert;
        err_ = CurvilinearTrajectoryError(C);
      }

      void setPropagationTargetZ(const float& z);
      void setPropagationTargetR(const float& r);
      void setPropagationTargetRZ(const float& r, const float& z);
      
      bool propagate(const double px, const double py, const double pz,
                     const double x,  const double y,  const double z,
                     const float charge, Coordinates& output) const;
      
      bool propagate(const math::XYZTLorentzVectorD& momentum,
                     const math::XYZTLorentzVectorD& position,
                     const float charge, Coordinates& output) const;
    
    private:
      SimpleTrackPropagator() :
        field_(nullptr),
        prod_(field_, alongMomentum),
        absz_target_(0),
        r_target_(0)
      {}

      const RKPropagatorInS&
      RKProp() const
      {
        return prod_.propagator;
      }

      Plane::PlanePointer targetPlaneForward_;
      Plane::PlanePointer targetPlaneBackward_;
      Cylinder::CylinderPointer targetCylinder_;

      const MagneticField* field_;
      CurvilinearTrajectoryError err_;
      defaultRKPropagator::Product prod_;
      float absz_target_;
      float r_target_;
  };

  void
  SimpleTrackPropagator::setPropagationTargetZ(const float& z)
  {
    targetPlaneForward_ = Plane::build(Plane::PositionType(0, 0, std::abs(z)),
                                       Plane::RotationType());
    targetPlaneBackward_= Plane::build(Plane::PositionType(0, 0, -std::abs(z)),
                                       Plane::RotationType());
    absz_target_ = std::abs(z);
  }

  void
  SimpleTrackPropagator::setPropagationTargetR(const float& r)
  {
    targetCylinder_ = Cylinder::build(r,
                                      Cylinder::PositionType(),
                                      Cylinder::RotationType());
    r_target_ = r;
  }

  void
  SimpleTrackPropagator::setPropagationTargetRZ(const float& r,
                                                const float& z)
  {
    setPropagationTargetR(r);
    setPropagationTargetZ(z);
  }

  bool
  SimpleTrackPropagator::propagate(const double px, const double py, const double pz,
                                   const double x,  const double y,  const double z,
                                   const float charge, Coordinates& output) const
  {
    output = Coordinates();

    using TSOS = TrajectoryStateOnSurface;
    
    GlobalPoint         startingPosition(x, y, z);
    GlobalVector        startingMomentum(px, py, pz);
    Plane::ConstPlanePointer startingPlane = Plane::build(Plane::PositionType(x, y, z),
                                                     Plane::RotationType());
    Cylinder::ConstCylinderPointer startingCylinder = Cylinder::build(std::hypot(x, y),
                                                                      Cylinder::PositionType(x, y, z),
                                                                      Cylinder::RotationType());
    TSOS startingStateP(GlobalTrajectoryParameters(startingPosition, startingMomentum, charge, field_),
                        err_,
                        *startingPlane);
    TSOS startingStateC(GlobalTrajectoryParameters(startingPosition, startingMomentum, charge, field_),
                        err_,
                        *startingCylinder);
    
    TSOS trackState;
    trackState = RKProp().propagate(startingStateC, *targetCylinder_);
    if (trackState.isValid())
    {
      if (trackState.globalPosition().z() < targetPlaneBackward_->position().z())
      {
        trackState = RKProp().propagate(startingStateP, *targetPlaneBackward_);
        if (!trackState.isValid()
            or trackState.globalPosition().perp() > targetCylinder_->radius())
        { return false;}
      } else if (trackState.globalPosition().z() > targetPlaneForward_->position().z())
      {
        trackState = RKProp().propagate(startingStateP, *targetPlaneForward_);
        if (!trackState.isValid()
            or trackState.globalPosition().perp() > targetCylinder_->radius())
        { return false;}
      }
    } else
    {
      return false;
    }


    output.x   = trackState.globalPosition().x();
    output.y   = trackState.globalPosition().y();
    output.z   = trackState.globalPosition().z();
    output.eta = trackState.globalPosition().eta();
    output.phi = trackState.globalPosition().phi();

    return true;

  }

  bool
  SimpleTrackPropagator::propagate(const math::XYZTLorentzVectorD& momentum,
                                   const math::XYZTLorentzVectorD& position,
                                   const float charge, Coordinates& output) const
  {
    return propagate(momentum.px(), momentum.py(), momentum.pz(),
                     position.x(), position.y(), position.z(),
                     charge, output);
  }

} // namespace ff


class ffNtupleGen : public ffNtupleBase
{
  public:
    ffNtupleGen(const edm::ParameterSet&);

    void initialize(TTree&, const edm::ParameterSet&, edm::ConsumesCollector&&) final;
    void fill(const edm::Event&, const edm::EventSetup&) final;
    void fill(const edm::Event&, const edm::EventSetup&, HLTConfigProvider&) override {}

  
  private:
    void clear() final;

    
    edm::EDGetToken gen_token_;
    edm::EDGetToken gen_PU_token_;

    std::vector<std::pair<float, float>> cylinderBounds_;

    int gen_PUNumInt_;
    float gen_TrueNumInt_;

    std::vector<int>   gen_pid_;
    std::vector<int>   gen_charge_;
    math::XYZTLorentzVectorFCollection gen_p4_;
    std::vector<math::XYZPointF> gen_vtx_;
    
    std::vector<std::vector<float>> gen_posx_;
    std::vector<std::vector<float>> gen_posy_;
    std::vector<std::vector<float>> gen_posz_;

    std::vector<int>   gen2_pid_;
    std::vector<math::XYZPointF> gen2_vtx_;
    std::vector<float> gen2_dr_;
    std::vector<std::vector<float>> gen2_posdr_;
    std::vector<std::vector<float>> gen2_posdz_;

    const MagneticField* aField_;

    edm::EDGetToken simTracks_token_;
    edm::EDGetToken simVertices_token_;
    edm::EDGetToken hepmcev_token_;

    edm::ESWatcher<IdealMagneticFieldRecord> magfield_watcher_;
};

DEFINE_EDM_PLUGIN(ffNtupleFactory,
                  ffNtupleGen,
                  "ffNtupleGen");


ffNtupleGen::ffNtupleGen(const edm::ParameterSet& ps) :
  ffNtupleBase(ps)
{}

void
ffNtupleGen::initialize(TTree& tree,
                       const edm::ParameterSet& ps,
                       edm::ConsumesCollector&& cc)
{

  gen_token_ = cc.consumes<reco::GenParticleCollection>(ps.getParameter<edm::InputTag>("GenParticles"));
  gen_PU_token_ = cc.consumes<std::vector<PileupSummaryInfo>>(ps.getParameter<edm::InputTag>("GenPU"));

  tree.Branch("gen_PUNumInt",   &gen_PUNumInt_ ,   "gen_PUNumInt/I");
  tree.Branch("gen_TrueNumInt", &gen_TrueNumInt_ , "gen_TrueNumInt/F");

  const std::vector<edm::ParameterSet>& cylinder_rz_ = ps.getParameterSetVector("CylinderRZ");
  for (const auto& rz : cylinder_rz_)
  {
    const double& r_ = rz.getParameter<double>("radius");
    const double& z_ = rz.getParameter<double>("absZ");
    cylinderBounds_.emplace_back(r_, z_);
  }


  tree.Branch("gen_charge", &gen_charge_);
  tree.Branch("gen_pid",    &gen_pid_);
  tree.Branch("gen_p4",     &gen_p4_);
  tree.Branch("gen_vtx",    &gen_vtx_);
  tree.Branch("gen_posx",   &gen_posx_);
  tree.Branch("gen_posy",   &gen_posy_);
  tree.Branch("gen_posz",   &gen_posz_);

  tree.Branch("gen2_vtx",   &gen2_vtx_);
  tree.Branch("gen2_dr",    &gen2_dr_);
  tree.Branch("gen2_pid",   &gen2_pid_);
  tree.Branch("gen2_posdr", &gen2_posdr_);
  tree.Branch("gen2_posdz", &gen2_posdz_);

}

void
ffNtupleGen::fill(const edm::Event& e,
                  const edm::EventSetup& es)
{
  clear();

  using namespace edm;
  using namespace std;
  Handle<vector<PileupSummaryInfo>> PupInfo_h;
  e.getByToken(gen_PU_token_, PupInfo_h);
  const vector<PileupSummaryInfo>& PupInfo = *PupInfo_h;

  if (magfield_watcher_.check(es))
  {
    ESHandle<MagneticField> magfield;
    es.get<IdealMagneticFieldRecord>().get(magfield);
    aField_ = &(*magfield);
  }



  Handle<vector<reco::GenParticle>> gen_h;
  e.getByToken(gen_token_, gen_h);

  map<size_t, size_t> myGenIndex; // bookkeeping
  vector<float> xp{}, yp{}, zp{};
  for (const auto& particle : *gen_h)
  {
    if (!particle.isHardProcess()
        or abs(particle.pdgId())<9)
    {
      continue;
    }


    const auto& vtx = particle.vertex();
    
    gen_charge_.push_back(particle.charge());
    gen_pid_.push_back(particle.pdgId());
    gen_p4_.emplace_back(particle.px(), particle.py(), particle.pz(), particle.energy());
    gen_vtx_.emplace_back(vtx.X(), vtx.Y(), vtx.Z());



    xp.clear(); yp.clear(); zp.clear();

    // propagation for charged particles
    if (particle.charge()!=0)
    {
      ff::SimpleTrackPropagator indivPropagator(aField_);
      for (const auto& cbound : cylinderBounds_)
      {
        const float& cb_r = cbound.first;
        const float& cb_z = cbound.second;

        float _x(NAN), _y(NAN), _z(NAN);

        if (    abs(vtx.Z())   <= cb_z
            and abs(vtx.Rho()) <= cb_r)
        {
          indivPropagator.setPropagationTargetRZ(cb_r, cb_z);
          ff::Coordinates propcoords;
          
          bool propsucess;
          propsucess = indivPropagator.propagate(particle.px(), particle.py(), particle.pz(),
                                                 vtx.x(), vtx.y(), vtx.z(),
                                                 particle.charge(),
                                                 propcoords);
          if (propsucess)
          {
            _x   = propcoords.x;
            _y   = propcoords.y;
            _z   = propcoords.z;
          }
        }

        xp  .push_back(_x);
        yp  .push_back(_y);
        zp  .push_back(_z);
      }
    }

    gen_posx_  .push_back(xp);
    gen_posy_  .push_back(yp);
    gen_posz_  .push_back(zp);
    
    size_t parIdx = &particle - &((*gen_h)[0]);
    myGenIndex[parIdx] = gen_posx_.size() - 1;

  }

  // gen2
  for (auto i(myGenIndex.begin()); i!=myGenIndex.end(); ++i)
  {
    const auto& parA = (*gen_h)[i->first];
    const size_t idxA = i->second;

    if (parA.charge()==0) continue;

    for (auto j(next(i)); j!=myGenIndex.end(); ++j)
    {
      const auto& parB = (*gen_h)[j->first];
      const size_t idxB = j->second;

      if (parB.charge()==0) continue;
      if (abs(parA.pdgId()) != abs(parB.pdgId())) continue;
      if (parA.vertex() != parB.vertex()) continue;

      const auto& vtx2 = parA.vertex();
      float _dr = deltaR(parA, parB);
      int _pid = abs(parA.pdgId());
      vector<float> _posdrs, _posdzs;

      for (size_t i(0); i!=cylinderBounds_.size(); ++i)
      {
        float& _xA = gen_posx_[idxA][i];
        float& _yA = gen_posy_[idxA][i];
        float& _zA = gen_posz_[idxA][i];
        float& _xB = gen_posx_[idxB][i];
        float& _yB = gen_posy_[idxB][i];
        float& _zB = gen_posz_[idxB][i];
        float _posdr(NAN), _posdz(NAN);

        if (    _xA!=NAN and _yA!=NAN and _zA!=NAN
            and _xB!=NAN and _yB!=NAN and _zB!=NAN)
        {
          _posdr = hypot((_xA - _xB), (_yA - _yB));
          _posdz = abs(_zA - _zB);
        }
        
        _posdrs.push_back(_posdr);
        _posdzs.push_back(_posdz);
      }

      gen2_vtx_.emplace_back(vtx2.X(), vtx2.Y(), vtx2.Z());
      gen2_dr_.push_back(_dr);
      gen2_pid_.push_back(_pid);
      gen2_posdr_.push_back(_posdrs);
      gen2_posdz_.push_back(_posdzs);

    }
  }


  for(const auto& PVI : PupInfo)
  {
    if(PVI.getBunchCrossing() == 0)
    { 
      gen_PUNumInt_ = PVI.getPU_NumInteractions();
      gen_TrueNumInt_ = PVI.getTrueNumInteractions();
    }
  }


}

void
ffNtupleGen::clear()
{
  gen_PUNumInt_ = 0;
  gen_TrueNumInt_ = 0.;

  gen_charge_.clear();
  gen_pid_.clear();
  gen_p4_.clear();
  gen_vtx_.clear();

  gen_posx_.clear();
  gen_posy_.clear();
  gen_posz_.clear();
  
  gen2_vtx_.clear();
  gen2_dr_.clear();
  gen2_pid_.clear();
  gen2_posdr_.clear();
  gen2_posdz_.clear();
}